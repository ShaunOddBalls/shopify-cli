      {% if customer && customer.email contains '@mmyoddballs.com' %}      {% endif %}
      <script>

/**
 * CRO FEATURE TRACKER
 * 
 * USAGE INSTRUCTIONS:
 * 
 * 1. BASIC SETUP:
 *    Include this script in your theme or page template
 * 
 * 2. MARK CRO FEATURES (New Granular System):
 *    Use specific attributes to control which events get tracked:
 *    
 *    <!-- Track when popup appears and becomes visible -->
 *    <div data-cro-feature-loaded="quick-buy-popup" 
 *         data-cro-feature-viewed="quick-buy-popup">
 *      <!-- Track only button clicks -->
 *      <button data-cro-feature-clicked="quick-buy-add-to-cart">Add to Cart</button>
 *    </div>
 *    
 *    <!-- Track all events (legacy support) -->
 *    <section data-cro-feature="testimonials-carousel">
 *      <!-- Testimonials -->
 *    </section>
 *    
 *    <!-- Track only clicks -->
 *    <button data-cro-feature-clicked="newsletter-signup">Subscribe</button>
 * 
 * 3. FEATURE NAMING:
 *    Use descriptive, kebab-case names:
 *    ‚úÖ Good: "product-recommendations", "exit-intent-popup", "social-proof-banner"
 *    ‚ùå Bad: "feature1", "test", "div"
 * 
 * 4. EVENTS TRACKED:
 *    - feature_loaded: When element appears in DOM (data-cro-feature-loaded)
 *    - feature_viewed: When element becomes visible (data-cro-feature-viewed)
 *    - feature_interacted: When user interacts with element (data-cro-feature-clicked)
 * 
 * 5. DYNAMIC CONTENT:
 *    Works automatically with AJAX/dynamic content - no additional setup needed
 * 
 * 6. DEBUGGING:
 *    Check browser console for "üéØ CRO Feature Tracker" messages
 *    Events are sent to Shopify Analytics and logged to your pixel tracking system
 * 
 * 7. A/B TESTING:
 *    Add data-experiment-id to automatically assign cohorts (A/B):
 *    
 *    <!-- A/B test example - cohort assigned automatically -->
 *    <div data-cro-feature-loaded="quick-buy-popup" 
 *         data-experiment-id="quick-buy-test-001">
 *      <!-- This element gets: -->
 *      <!-- - data-test-group="a" or "b" -->
 *      <!-- - CSS class "cohort-a" or "cohort-b" -->
 *      <!-- Body gets: -->
 *      <!-- - data-experiment-quick-buy-test-001="a" or "b" -->
 *      <!-- - CSS class "experiment-quick-buy-test-001-a" or "experiment-quick-buy-test-001-b" -->
 *    </div>
 *    
 * 8. URL PARAMETER TESTING (for QA/testing):
 *    Force specific cohorts using URL parameters:
 *    
 *    ?cohort=a                           // Force all experiments to cohort A
 *    ?test=b                             // Force all experiments to cohort B  
 *    ?experiment-quick-buy-test-001=a    // Force specific experiment to cohort A
 *    
 *    Examples:
 *    https://yourstore.com/products/shirt?cohort=a
 *    https://yourstore.com/?experiment-quick-buy-test-001=b&experiment-banner-test=a
 *    
 *    <!-- CSS styling examples -->
 *    <style>
 *     	// Style specific element
 *      .cohort-a .quick-buy-button { background: blue; }
 *      .cohort-b .quick-buy-button { background: green; }
 *      
 *     	// Style entire page based on experiment
 *      body.experiment-quick-buy-test-001-a .header { display: none; }
 *      body.experiment-quick-buy-test-001-b .footer { background: red; }
 *      
 *     	// Or use attributes
 *      body[data-experiment-quick-buy-test-001="a"] .sidebar { width: 300px; }
 *      body[data-experiment-quick-buy-test-001="b"] .sidebar { width: 250px; }
 *    </style>
 *    
 *     	// Access cohort in JavaScript:
 *      // Check specific experiment cohort
 *      // console.log(window.cro_experiments['quick-buy-test-001']); // "a" or "b"
 *      
 *      // Check default cohort (always available)
 *      // console.log(window.cro_experiments.default); // "a" or "b"
 *      // console.log(window.cro_default_cohort); // "a" or "b"
 * 
 * 9. EXAMPLES:
 *    <!-- Product page upsell -->
 *    <div data-cro-feature="product-upsell-recommendations">
 *      <h3>You might also like</h3>
 *      <!-- products -->
 *    </div>
 *    
 *    <!-- Cart drawer with A/B testing -->
 *    <div data-cro-feature="cart-drawer-upsells" 
 *         data-experiment-id="cart-upsell-test"
 *         class="cart-drawer">
 *      <!-- cart content -->
 *    </div>
 *    
 *    <!-- Exit intent popup -->
 *    <div data-cro-feature="exit-intent-discount-popup" id="exit-popup">
 *      <!-- popup content -->
 *    </div>
 */

(function() {
	// --- CRO FEATURE TRACKER ---
	// Tracks: feature_loaded ‚Üí feature_viewed ‚Üí feature_interacted
	
	// Debug flag - set to false for production
	const CRO_DEBUG = true; // Change to false in production
	
	// Debug helper functions to guard all console output
	const log = (...args) => { if (CRO_DEBUG) console.log(...args); };
	const warn = (...args) => { if (CRO_DEBUG) console.warn(...args); };
	const err = (...args) => { if (CRO_DEBUG) console.error(...args); };
	
	const FEATURE_TRACKER = {
	  // Track which features have been loaded/viewed to avoid duplicates
	  loadedFeatures: new Set(), // By feature name (preserves existing behavior)
	  viewedFeatures: new Set(), // By feature name (preserves existing behavior)
	  
	  // Element-scoped tracking to prevent reprocessing same DOM nodes
	  loadedElements: new WeakSet(),
	  viewedElements: new WeakSet(),
	  
	  // A/B Testing cohort management
	  cohortCache: new Map(), // Cache cohort assignments per experiment
	  defaultCohortAssigned: false, // Track if default cohort has been set
	  
	  // Theme info tracking
	  themeInfoPublished: false, // Track if theme info has been published
	  
	  // Performance optimizations
	  _storageAvailable: null, // Cache storage availability check
	  _delegatedListenerSetup: false, // Track if delegated listener is set up
	  
	  // Intersection Observer for visibility tracking
	  viewObserver: null,
	  
	  // Performance optimization: debounce DOM queries and cache results
	  _domQueryCache: new Map(),
	  _domQueryCacheMax: 50, // Cap cache size to prevent unbounded growth
	  _lastCacheTime: 0,
	  _cacheTimeout: 1000, // 1 second cache for DOM queries
	  
	  // Event throttling to prevent spam
	  _eventThrottle: new Map(),
	  _throttleTimeout: 500, // 500ms throttle per event type per feature
	  
	  // Theme Info Publishing
	  publishThemeInfo() {
		try {
		  // Only publish once per page load
		  if (this.themeInfoPublished) return;
		  
		  // Get theme info from Shopify global (if available)
		  const shopifyTheme = window.Shopify?.theme;
		  const themeInfo = {
			theme_id: shopifyTheme?.id?.toString() || 'unknown',
			theme_name: shopifyTheme?.name || 'unknown',
			theme_role: shopifyTheme?.role || 'unknown'
		  };
		  
		  // Publish theme info via analytics (with retry for timing)
		  this.publishThemeInfoWithRetry(themeInfo, 0);
		} catch (error) {
		  if (CRO_DEBUG) {
			err('üé® [CRO] Failed to publish theme info:', error);
		  }
		  // Don't throw - this is non-critical functionality
		}
	  },
			
	  // Theme info publishing with smart retry
	  publishThemeInfoWithRetry(themeInfo, attempt) {
		const maxAttempts = 50; // Try for up to 5 seconds (50 * 100ms)
		
		if (window.Shopify && Shopify.analytics && Shopify.analytics.publish) {
		  const eventPayload = {
			name: 'custom_theme_info',
			customData: themeInfo
		  };
		  
		  Shopify.analytics.publish("custom_event", eventPayload);
		  this.themeInfoPublished = true;
		  
		  if (CRO_DEBUG) {
			log('üé® [CRO] Published theme info via Shopify.analytics:', themeInfo);
		  }
		} else if (attempt < maxAttempts) {
		  if (CRO_DEBUG) {
			if (attempt === 0) {
			  warn('üé® [CRO] Analytics not ready, will retry for up to 5 seconds...');
			} else if (attempt % 10 === 0) {
			  warn(`üé® [CRO] Still waiting for analytics... attempt ${attempt}/${maxAttempts}`);
			}
		  }
		  
		  setTimeout(() => {
			this.publishThemeInfoWithRetry(themeInfo, attempt + 1);
		  }, 100);
		} else {
		  if (CRO_DEBUG) {
			warn('üé® [CRO] Shopify.analytics never became available, giving up after 5 seconds');
			warn('üé® [CRO] window.Shopify:', window.Shopify);
			warn('üé® [CRO] Shopify.analytics:', window.Shopify?.analytics);
		  }
		}
	  },
	  
	  // A/B Testing Methods
	  getOrCreateCohort(experimentId) {
		if (!experimentId) return null;
		
		// Check cache first
		if (this.cohortCache.has(experimentId)) {
		  return this.cohortCache.get(experimentId);
		}
		
		// Check URL parameters first (for testing)
		const urlCohort = this.getCohortFromUrl(experimentId);
		if (urlCohort) {
		  this.cohortCache.set(experimentId, urlCohort);
		  if (CRO_DEBUG) log(`üß™ [CRO] Using URL cohort ${urlCohort} for experiment: ${experimentId}`);
		  return urlCohort;
		}
		
		// Check sessionStorage (GDPR-compliant, no consent needed)
		const storageKey = `cro_cohort_${experimentId}`;
		let cohort = sessionStorage.getItem(storageKey);
		
		if (!cohort) {
		  // Generate session ID for consistent assignment
		  let sessionId = sessionStorage.getItem('cro_session_id');
		  if (!sessionId) {
			sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
			sessionStorage.setItem('cro_session_id', sessionId);
		  }
		  
		  // Assign cohort based on session ID + experiment ID
		  const combinedId = sessionId + experimentId;
		  const hash = combinedId.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
		  cohort = hash % 2 === 0 ? 'a' : 'b';
		  
		  // Store in sessionStorage (functional use, no consent required)
		  sessionStorage.setItem(storageKey, cohort);
		  
		  if (CRO_DEBUG) log(`üß™ [CRO] Assigned cohort ${cohort} for experiment: ${experimentId}`);
		}
		
		// Cache for performance
		this.cohortCache.set(experimentId, cohort);
		return cohort;
	  },
	  
	  assignCohortToElement(element, experimentId) {
		if (!element || !experimentId) return;
		
		const cohort = this.getOrCreateCohort(experimentId);
		if (cohort) {
		  // Normalize experimentId for safe CSS class names
		  const safeId = String(experimentId).replace(/[^a-z0-9-_]/gi, '-');
		  
		  // Set the test_group attribute on element
		  element.setAttribute('data-test-group', cohort);
		  
		  // Add CSS class to element for styling
		  element.classList.add(`cohort-${cohort.toLowerCase()}`);
		  
		  // Add cohort attribute to body for page-wide styling
		  const bodyAttrName = `data-experiment-${safeId}`;
		  document.body.setAttribute(bodyAttrName, cohort);
		  document.body.classList.add(`experiment-${safeId}-${cohort.toLowerCase()}`);
		  
		  // Make globally available
		  window.cro_experiments = window.cro_experiments || {};
		  window.cro_experiments[safeId] = cohort;
		  
		  if (CRO_DEBUG) {
			log(`üß™ [CRO] Element and body assigned to cohort ${cohort} for experiment: ${safeId}`);
			log(`üß™ [CRO] window.cro_experiments now contains:`, window.cro_experiments);
		  }
		  
		  // Send updated cohort info to backend
		  this.updateSessionCohorts();
		}
	  },
	  
	// Get cohort from URL parameters (for testing)
	getCohortFromUrl(experimentId) {
	  try {
		const urlParams = new URLSearchParams(window.location.search);
		
		// Check for experiment-specific parameter: ?experiment-quick-buy=a
		const experimentParam = urlParams.get(`experiment-${experimentId}`);
		if (experimentParam && (experimentParam === 'a' || experimentParam === 'b')) {
		  return experimentParam;
		}
		
		// Check for generic cohort parameter: ?cohort=a
		const cohortParam = urlParams.get('cohort');
		if (cohortParam && (cohortParam === 'a' || cohortParam === 'b')) {
		  return cohortParam;
		}
		
		// Check for test group parameter: ?test=a
		const testParam = urlParams.get('test');
		if (testParam && (testParam === 'a' || testParam === 'b')) {
		  return testParam;
		}
		
		return null;
	  } catch (error) {
		warn('üß™ [CRO] Error reading URL parameters:', error);
		return null;
	  }
	},
  
	// Check if storage is available and working
	isStorageAvailable(type) {
		try {
		  const storage = window[type];
		  const test = '__storage_test__';
		  storage.setItem(test, test);
		  storage.removeItem(test);
		  return true;
		} catch (e) {
		  return false;
		}
	  },
	  
	  // Generate consistent cohort ID that works without storage
	  generateConsistentId() {
		// Try multiple fallback methods for consistent ID generation
		const currentYear = new Date().getFullYear();
		
		const fallbacks = [
		  // Stable browser fingerprint + year (most stable elements only)
		  () => navigator.userAgent + navigator.language + navigator.platform + currentYear,
		  // Simplified fingerprint + year (if platform fails)
		  () => navigator.userAgent + navigator.language + currentYear,
		  // URL-based + year (consistent per page per year)
		  () => window.location.hostname + window.location.pathname + currentYear,
		  // Time-based (changes every hour - better than random)
		  () => Math.floor(Date.now() / (1000 * 60 * 60)).toString(),
		  // Last resort - truly random (will change every page load)
		  () => Math.random().toString()
		];
		
		for (const fallback of fallbacks) {
		  try {
			const id = fallback();
			if (id && id.length > 5) {
			  return id;
			}
		  } catch (e) {
			continue;
		  }
		}
		
		return 'fallback_' + Date.now();
	  },
	  
	  // Get the default cohort (always available)
	  getDefaultCohort() {
		if (window.cro_default_cohort) {
		  return window.cro_default_cohort;
		}
		
		// If not set yet, assign it now
		this.assignDefaultCohort();
		return window.cro_default_cohort || 'a'; // fallback
	  },
	  
	  assignDefaultCohort() {
		if (this.defaultCohortAssigned) return;
		
		// Check URL parameters first (for testing)
		const urlCohort = this.getCohortFromUrl('default');
		if (urlCohort) {
		  document.body.setAttribute('data-default-cohort', urlCohort);
		  document.body.classList.add(`default-cohort-${urlCohort}`);
		  window.cro_experiments = window.cro_experiments || {};
		  window.cro_experiments.default = urlCohort;
		  window.cro_default_cohort = urlCohort;
		  this.defaultCohortAssigned = true;
		  if (CRO_DEBUG) log(`üß™ [CRO] Using URL default cohort: ${urlCohort}`);
		  return;
		}
		
		let sessionId;
		let defaultCohort;
		let storageWorking = false;
		
		// Try sessionStorage first (use cached availability)
		if (this._storageAvailable !== null ? this._storageAvailable : this.isStorageAvailable('sessionStorage')) {
		  try {
			sessionId = sessionStorage.getItem('cro_session_id');
			defaultCohort = sessionStorage.getItem('cro_default_cohort');
			storageWorking = true;
		  } catch (e) {
			warn('üß™ [CRO] sessionStorage read failed:', e.message);
		  }
		}
		
		// Generate session ID if not found or storage not working
		if (!sessionId) {
		  if (storageWorking) {
			sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
			try {
			  sessionStorage.setItem('cro_session_id', sessionId);
			} catch (e) {
			  warn('üß™ [CRO] sessionStorage write failed:', e.message);
			  storageWorking = false;
			}
		  } else {
			// Use consistent fallback ID
			sessionId = this.generateConsistentId();
			warn('üß™ [CRO] Using fallback ID generation (no storage available)');
		  }
		}
		
		// Generate cohort if not found
		if (!defaultCohort) {
		  const hash = sessionId.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
		  defaultCohort = hash % 2 === 0 ? 'a' : 'b';
		  
		  if (storageWorking) {
			try {
			  sessionStorage.setItem('cro_default_cohort', defaultCohort);
			  if (CRO_DEBUG) log(`üß™ [CRO] Assigned default cohort: ${defaultCohort} (stored)`);
			} catch (e) {
			  if (CRO_DEBUG) warn('üß™ [CRO] Could not store cohort:', e.message);
			  if (CRO_DEBUG) log(`üß™ [CRO] Assigned default cohort: ${defaultCohort} (not stored - may change on reload)`);
			}
		  } else {
			if (CRO_DEBUG) log(`üß™ [CRO] Assigned default cohort: ${defaultCohort} (no storage - using fingerprint)`);
		  }
		}
		
		// Set default cohort on body and globally
		document.body.setAttribute('data-default-cohort', defaultCohort);
		document.body.classList.add(`default-cohort-${defaultCohort}`);
		
		// Make globally available
		window.cro_experiments = window.cro_experiments || {};
		window.cro_experiments.default = defaultCohort;
		window.cro_default_cohort = defaultCohort;
		
		this.defaultCohortAssigned = true;
		if (CRO_DEBUG) log(`üß™ [CRO] Default cohort ${defaultCohort} applied to body and window.cro_experiments.default`);
		
		// Send cohort info to backend to update session
		this.updateSessionCohorts();
	  },
	  
	  // Send cohort information to backend to update session traits
	  updateSessionCohorts() {
		try {
		  const cohortData = {
			default_cohort: window.cro_default_cohort
		  };
		  
		  // Add any active experiment cohorts
		  if (window.cro_experiments) {
			Object.keys(window.cro_experiments).forEach(experimentId => {
			  if (experimentId !== 'default') {
				cohortData[`experiment_${experimentId}`] = window.cro_experiments[experimentId];
			  }
			});
		  }
		  
		  // Send as a custom event to update session traits
		  if (window.Shopify && Shopify.analytics && Shopify.analytics.publish) {
			const eventPayload = {
			  name: 'cro_cohort_assignment',
			  customData: {
				event_type: 'cohort_assignment',
				cohorts: cohortData,
				timestamp: Date.now()
			  }
			};
			
			Shopify.analytics.publish("custom_event", eventPayload);
			if (CRO_DEBUG) log('üß™ [CRO] Sent cohort data to backend:', cohortData);
		  }
		} catch (error) {
		  warn('üß™ [CRO] Failed to send cohort data to backend:', error);
		}
	  },
	  
	  // Performance-optimized DOM query with caching
	  _queryDOMWithCache(selector) {
		const now = Date.now();
		
		// Clear cache if it's expired
		if (now - this._lastCacheTime > this._cacheTimeout) {
		  this._domQueryCache.clear();
		  this._lastCacheTime = now;
		}
		
		// Return cached result if available
		if (this._domQueryCache.has(selector)) {
		  return this._domQueryCache.get(selector);
		}
		
		// Query DOM and cache result
		try {
		  const elements = document.querySelectorAll(selector);
		  
		  // Respect cache size limit
		  if (this._domQueryCache.size >= this._domQueryCacheMax) {
			// Remove oldest entry to make room
			const firstKey = this._domQueryCache.keys().next().value;
			this._domQueryCache.delete(firstKey);
		  }
		  
		  this._domQueryCache.set(selector, elements);
		  return elements;
		} catch (error) {
		  this.handleError('DOM query failed', error, { selector });
		  return [];
		}
	  },
  
	  // Initialize the tracker with comprehensive error handling
	  init() {
		try {
		  // Cache storage availability once
		  this._storageAvailable = this.isStorageAvailable('sessionStorage');
		  
		  // Publish theme info first (early in page load)
		  this.publishThemeInfo();
		  
		  // Assign default cohort first (always available)
		  this.assignDefaultCohort();
		  
		  this.setupViewObserver();
		  this.setupDelegatedInteractionListener();
		  this.scanForExistingFeatures();
		  this.setupDynamicTracking();
		  
		  if (CRO_DEBUG) {
			log("üéØ CRO Feature Tracker initialized");
			log(`üéØ [CRO-TRACKER] [INIT] loadedFeatures size: ${this.loadedFeatures.size}`);
			log(`üéØ [CRO-TRACKER] [INIT] viewedFeatures size: ${this.viewedFeatures.size}`);
		  }
		} catch (error) {
		  this.handleError('Initialization failed', error);
		  // Continue with basic functionality even if some parts fail
		}
	  },
	  
	  // Setup delegated interaction listener (one listener for all interactions)
	  setupDelegatedInteractionListener() {
		if (this._delegatedListenerSetup) return;
		
		try {
		  // Single delegated listener for all CRO interactions
		  document.addEventListener('click', (event) => {
			try {
			  // Guard against non-Element targets (text nodes, etc.)
			  const t = event.target;
			  if (!(t instanceof Element)) return;
			  
			  log('üéØ [CRO-TRACKER] [CLICK] Click detected on:', t.tagName, t.className);
			  
			  // Check if clicked element or any parent has CRO interaction attributes
			  const croElement = t.closest('[data-cro-feature-clicked], [data-cro-feature]');
			  
			  if (croElement) {
				// Determine which attribute to use and store on element
				let attributeName = 'data-cro-feature-clicked';
				if (!croElement.hasAttribute('data-cro-feature-clicked') && croElement.hasAttribute('data-cro-feature')) {
				  attributeName = 'data-cro-feature';
				}
				croElement._croAttributeName = attributeName;
				
				log(`üéØ [CRO-TRACKER] [CLICK] Found CRO element with ${attributeName}:`, croElement.getAttribute(attributeName));
				
				// Track the interaction (fix argument order: feature, interactionType, event)
				this.trackFeatureInteraction(croElement, 'click', event);
			  } else {
				log('üéØ [CRO-TRACKER] [CLICK] No CRO attributes found on clicked element or parents');
			  }
			} catch (error) {
			  this.handleError('Delegated click handler error', error, { target: event.target });
			}
		  }, { passive: true, capture: true });
		  
		  this._delegatedListenerSetup = true;
		  if (CRO_DEBUG) {
			log('üéØ CRO Tracker: Delegated interaction listener set up');
			log('üéØ CRO Tracker: Click anywhere to test - you should see click detection logs');
		  }
		} catch (error) {
		  this.handleError('Failed to setup delegated interaction listener', error);
		}
	  },
	  
	  // Setup Intersection Observer for "viewed" events with error handling
	  setupViewObserver() {
		try {
		  // Check if IntersectionObserver is supported
		  if (!window.IntersectionObserver) {
			warn("üéØ CRO Tracker: IntersectionObserver not supported, skipping view tracking");
			return;
		  }
  
		  this.viewObserver = new IntersectionObserver((entries) => {
			try {
			  entries.forEach(entry => {
				try {
				  const feature = entry.target;
				  const attributeName = feature._croAttributeName || 'data-cro-feature';
				  const featureName = feature.getAttribute(attributeName);
				  
				  // Fire when element is intersecting and at least 25% visible, OR when it reaches 50% visible
				  const isPartiallyVisible = entry.isIntersecting && entry.intersectionRatio >= 0.25;
				  const isSignificantlyVisible = entry.isIntersecting && entry.intersectionRatio >= 0.5;
				  
				  if (isPartiallyVisible || isSignificantlyVisible) {
					if (!feature || !featureName) return;
					
					// Only fire once per element when it becomes visible in viewport
					if (!this.viewedFeatures.has(featureName)) {
					  // Let trackFeatureViewed handle adding to the set - don't add here
					  this.trackFeatureViewed(feature);
					  // Stop observing this element since we've already fired the viewed event
					  this.viewObserver.unobserve(feature);
					}
				  }
				} catch (entryError) {
				  this.handleError('Entry processing error', entryError);
				}
			  });
			} catch (entriesError) {
			  this.handleError('Entries processing error', entriesError);
			}
		  }, {
			threshold: [0.1, 0.25, 0.5, 0.75], // Multiple thresholds to catch different visibility levels
			rootMargin: '0px'
		  });
		} catch (error) {
		  this.handleError('View observer setup failed', error);
		}
	  },
	  
	  // Scan for features that are already on the page with error handling
	  scanForExistingFeatures() {
		try {
		  // Scan for loaded features (performance optimized)
		  try {
			const loadedFeatures = this._queryDOMWithCache('[data-cro-feature-loaded]');
			loadedFeatures.forEach(feature => {
			  try {
				this.trackFeatureLoaded(feature, 'data-cro-feature-loaded');
			  } catch (error) {
				this.handleError('Error tracking loaded feature', error, feature);
			  }
			});
		  } catch (error) {
			this.handleError('Error scanning loaded features', error);
		  }
  
		  // Scan for viewed features (add to observer) - performance optimized
		  try {
			const viewedFeatures = this._queryDOMWithCache('[data-cro-feature-viewed]');
			viewedFeatures.forEach(feature => {
			  try {
				this.startViewTracking(feature, 'data-cro-feature-viewed');
			  } catch (error) {
				this.handleError('Error setting up view tracking', error, feature);
			  }
			});
		  } catch (error) {
			this.handleError('Error scanning viewed features', error);
		  }
  
		  // Note: Interaction tracking now uses delegated event listener (no individual setup needed)
  
		  // Legacy support: scan for old data-cro-feature (tracks all events) - performance optimized
		  try {
			const legacyFeatures = this._queryDOMWithCache('[data-cro-feature]');
			legacyFeatures.forEach(feature => {
			  try {
				// Set up view tracking FIRST, before firing loaded event
				this.startViewTracking(feature, 'data-cro-feature');
				this.trackFeatureLoaded(feature, 'data-cro-feature');
				// Note: Interaction tracking now uses delegated listener
			  } catch (error) {
				this.handleError('Error setting up legacy feature', error, feature);
			  }
			});
		  } catch (error) {
			this.handleError('Error scanning legacy features', error);
		  }
		} catch (error) {
		  this.handleError('Critical error in scanForExistingFeatures', error);
		}
	  },
	  
	  // Setup MutationObserver for dynamically added features with error handling
	  setupDynamicTracking() {
		try {
		  // Check if MutationObserver is supported
		  if (!window.MutationObserver) {
			warn("üéØ CRO Tracker: MutationObserver not supported, skipping dynamic tracking");
			return;
		  }
  
		  const observer = new MutationObserver((mutations) => {
			try {
			  mutations.forEach(mutation => {
				try {
			mutation.addedNodes.forEach(node => {
			  if (node.nodeType === Node.ELEMENT_NODE) {
				// Check if the added node itself has any CRO feature attributes
				if (node.hasAttribute) {
				  if (node.hasAttribute('data-cro-feature-loaded')) {
					this.trackFeatureLoaded(node, 'data-cro-feature-loaded');
				  }
				  if (node.hasAttribute('data-cro-feature-viewed')) {
					this.startViewTracking(node, 'data-cro-feature-viewed');
				  }
				  // Note: Interaction tracking now uses delegated listener
				  // Legacy support
				  if (node.hasAttribute('data-cro-feature')) {
					this.handleNewFeature(node);
				  }
				}
				
				// Check for features within the added node
				if (node.querySelectorAll) {
				  // New attribute system
				  const loadedFeatures = node.querySelectorAll('[data-cro-feature-loaded]');
				  loadedFeatures.forEach(feature => this.trackFeatureLoaded(feature, 'data-cro-feature-loaded'));
				  
				  const viewedFeatures = node.querySelectorAll('[data-cro-feature-viewed]');
				  viewedFeatures.forEach(feature => this.startViewTracking(feature, 'data-cro-feature-viewed'));
				  
				  // Note: Interaction tracking now uses delegated listener (no setup needed)
				  
				  // Legacy support
				  const legacyFeatures = node.querySelectorAll('[data-cro-feature]');
				  legacyFeatures.forEach(feature => this.handleNewFeature(feature));
				}
			  }
			});
				} catch (mutationError) {
				  this.handleError('Mutation processing error', mutationError);
				}
			  });
			} catch (mutationsError) {
			  this.handleError('Mutations processing error', mutationsError);
			}
		  });
  
		  observer.observe(document.body, {
			childList: true,
			subtree: true
		  });
		} catch (error) {
		  this.handleError('Dynamic tracking setup failed', error);
		}
	  },
	  
	  // Handle newly discovered features
	  handleNewFeature(feature) {
		// Use element-level deduplication instead of feature name
		if (!this.loadedElements.has(feature)) {
		  this.trackFeatureLoaded(feature);
		  this.startViewTracking(feature);
		  // Note: Interaction tracking now uses delegated listener
		}
	  },
	  
	  // Generate unique feature ID
	  getFeatureId(feature, attributeName = 'data-cro-feature') {
		const featureName = feature.getAttribute(attributeName);
		const featureVariant = feature.getAttribute('data-feature-variant') || 'default';
		const featureId = feature.id || `${featureName}-${Date.now()}`;
		return `${featureName}:${featureVariant}:${featureId}`;
	  },
	  
	  // Track when feature is loaded (appears in DOM) with error handling
	  trackFeatureLoaded(feature, attributeName = 'data-cro-feature') {
		try {
		  if (!feature || !feature.getAttribute) return;
		  
		  // Check element-level tracking first (prevents reprocessing same DOM node)
		  if (this.loadedElements.has(feature)) return;
		  this.loadedElements.add(feature);
		  
		  // Auto-assign cohort if experiment ID is present
		  const experimentId = feature.getAttribute('data-experiment-id');
		  if (experimentId && !feature.getAttribute('data-test-group')) {
			this.assignCohortToElement(feature, experimentId);
		  }
		  
		  const featureId = this.getFeatureId(feature, attributeName);
		  if (!featureId) return;
		  
		  const featureData = this.extractFeatureData(feature, attributeName);
		  if (!featureData || !featureData.feature_name) {
			warn('üéØ CRO Tracker: feature_loaded - Invalid feature data:', {
			  featureData,
			  attributeName,
			  element: feature,
			  hasAttribute: feature.hasAttribute(attributeName),
			  attributeValue: feature.getAttribute(attributeName)
			});
			return;
		  }
		  
		  if (this.loadedFeatures.has(featureData.feature_name)) {
			log(`üéØ [CRO-TRACKER] [LOADED] ‚ö†Ô∏è DUPLICATE PREVENTED: ${featureData.feature_name} already loaded`);
			return;
		  }
		  
		  // Always track feature_loaded regardless of visibility - visibility is handled separately by feature_viewed
		  
		  this.loadedFeatures.add(featureData.feature_name);
		  log(`üéØ [CRO-TRACKER] [LOADED] Adding to loaded set: ${featureData.feature_name} (total: ${this.loadedFeatures.size})`);
		  
		  const eventData = {
			...featureData,
			load_method: this.getLoadMethod(feature),
			timestamp: Date.now()
		  };
		  
		  log(`üéØ [CRO-TRACKER] [LOADED] Sending feature_loaded event for: ${featureData.feature_name}`);
		  this.publishEvent('feature_loaded', eventData);
		  log(`üéØ [CRO-TRACKER] [LOADED] ‚úÖ Event sent for: ${featureData.feature_name}`);
		  
		} catch (error) {
		  this.handleError('Error tracking feature loaded', error, feature);
		}
	  },
	  
	  // Start tracking when feature becomes visible
	  startViewTracking(feature, attributeName = 'data-cro-feature') {
		// Store the attribute name on the element for later use
		feature._croAttributeName = attributeName;
		
		const featureName = feature.getAttribute(attributeName);
		
		// If we already fired viewed event, don't observe
		if (this.viewedFeatures.has(featureName)) {
		  return;
		}
		
		// Always set up the observer first
		if (this.viewObserver) {
		  this.viewObserver.observe(feature);
		}
		
		// Then check if element is already visible (25%+ in viewport) and fire immediately
		const isVisible = this.isElementVisible(feature);
		const visibilityPercentage = this.calculateVisibilityPercentage(feature);
		
		if (isVisible && visibilityPercentage >= 25) {
		  // Small delay to ensure the observer is set up first
		  setTimeout(() => {
			if (!this.viewedFeatures.has(featureName)) {
			  this.trackFeatureViewed(feature);
			}
		  }, 10);
		}
	  },
	  
	  // Track when feature is viewed (50% visible in viewport) - fires only once per element
	  trackFeatureViewed(feature) {
		try {
		  if (!feature || !feature.getAttribute) return;
		  
		  // Check element-level tracking first (prevents reprocessing same DOM node)
		  if (this.viewedElements.has(feature)) return;
		  this.viewedElements.add(feature);
		  
		  const attributeName = feature._croAttributeName || 'data-cro-feature';
		  const featureData = this.extractFeatureData(feature, attributeName);
		  
		  if (!featureData || !featureData.feature_name) return;
		  
		  // Double-check if we've already fired viewed for this feature
		  if (this.viewedFeatures.has(featureData.feature_name)) {
			return;
		  }
		  
		  // Add to viewed list before firing event
		  this.viewedFeatures.add(featureData.feature_name);
		  
		  // Reuse single getBoundingClientRect call
		  const rect = feature.getBoundingClientRect();
		  this.publishEvent('feature_viewed', {
			...featureData,
			viewport_info: this.getViewportInfo(feature, rect),
			timestamp: Date.now()
		  });
		  
		} catch (error) {
		  this.handleError('Error tracking feature viewed', error, feature);
		}
	  },
	  
	  // Setup interaction tracking for a feature
	  setupInteractionTracking(feature, attributeName = 'data-cro-feature') {
		// Store the attribute name on the element for later use
		feature._croAttributeName = attributeName;
		const interactionTypes = feature.getAttribute('data-cro-interactions') || 'click';
		const interactions = interactionTypes.split(',').map(s => s.trim());
		
		interactions.forEach(interaction => {
		  feature.addEventListener(interaction, (e) => {
			this.trackFeatureInteraction(feature, interaction, e);
		  });
		});
	  },
	  
	  // Track feature interactions
	  trackFeatureInteraction(feature, interactionType, event) {
		try {
		  if (!feature || !feature.getAttribute) {
			warn('üéØ [CRO-TRACKER] [INTERACTION] Invalid feature element');
			return;
		  }
  
		  const attributeName = feature._croAttributeName || 'data-cro-feature';
		  const featureData = this.extractFeatureData(feature, attributeName);
		  
		  if (!featureData || !featureData.feature_name) {
			warn('üéØ [CRO-TRACKER] [INTERACTION] No feature data found');
			return;
		  }
  
		  log(`üéØ [CRO-TRACKER] [INTERACTION] Tracking ${interactionType} for: ${featureData.feature_name}`);
		  
		  const interactionData = {
			...featureData,
			interaction_type: interactionType,
			interaction_details: this.getInteractionDetails(event),
			timestamp: Date.now()
		  };
		  
		  // Interactions are not throttled - each click should be tracked
		  this.publishEvent('feature_interacted', interactionData);
		  log(`üéØ [CRO-TRACKER] [INTERACTION] ‚úÖ Event sent for: ${featureData.feature_name}`);
		  
		} catch (error) {
		  this.handleError('Error tracking feature interaction', error, { feature, interactionType, event });
		}
	  },
	  
	  // Extract feature data from element with validation
	  extractFeatureData(feature, attributeName = 'data-cro-feature') {
		try {
		  if (!feature || !feature.getAttribute) return null;
		  
		  const featureName = feature.getAttribute(attributeName);
		  if (!featureName || featureName.trim() === '') {
			warn('üéØ CRO Tracker: Feature element missing or empty feature name attribute:', {
			  attributeName,
			  featureName,
			  element: feature,
			  allAttributes: Array.from(feature.attributes || []).map(attr => `${attr.name}="${attr.value}"`),
			  tagName: feature.tagName,
			  id: feature.id,
			  className: feature.className
			});
			return null;
		  }
		  
		  const rect = feature.getBoundingClientRect();
		  
		  // Get cohort information for A/B testing
		  const experimentId = feature.getAttribute('data-experiment-id');
		  const cohortData = {};
		  
		  if (experimentId) {
			const cohort = this.getOrCreateCohort(experimentId);
			if (cohort) {
			  cohortData.experiment_id = experimentId;
			  cohortData.test_group = cohort;
			}
		  }
		  
		  // Always include default cohort for analysis
		  cohortData.default_cohort = window.cro_default_cohort || this.getDefaultCohort();
		  
		  return {
			feature_name: featureName.trim(),
			feature_variant: feature.getAttribute('data-feature-variant') || 'default',
			feature_id: this.getFeatureId(feature, attributeName),
			element_id: feature.id || null,
			element_classes: feature.className || null,
			element_tag: feature.tagName,
			...cohortData, // Include cohort information
			position: {
			  x: Math.round(rect.x || 0),
			  y: Math.round(rect.y || 0),
			  width: Math.round(rect.width || 0),
			  height: Math.round(rect.height || 0)
			},
			page_url: window.location.href,
			page_path: window.location.pathname,
			// Custom attributes for A/B testing
			experiment_id: feature.getAttribute('data-experiment-id') || null,
			test_group: feature.getAttribute('data-test-group') || null,
			feature_version: feature.getAttribute('data-feature-version') || '1.0'
		  };
		} catch (error) {
		  this.handleError('Error extracting feature data', error, feature);
		  return null;
		}
	  },
	  
	  // Determine how the feature was loaded
	  getLoadMethod(feature) {
		// Check if feature was there on initial page load
		if (document.readyState === 'loading') {
		  return 'page_load';
		}
		
		// Check for common dynamic loading indicators
		if (feature.closest('[data-ajax-loaded]') || 
			feature.closest('.dynamic-content') ||
			feature.hasAttribute('data-dynamic')) {
		  return 'dynamic';
		}
		
		return 'unknown';
	  },
	  
	  // Get viewport information when feature is viewed
	  getViewportInfo(feature, rect) {
		rect = rect || feature.getBoundingClientRect();
		
		return {
		  viewport_width: window.innerWidth,
		  viewport_height: window.innerHeight,
		  scroll_x: window.scrollX,
		  scroll_y: window.scrollY,
		  element_visible_area: {
			top: Math.max(0, rect.top),
			bottom: Math.min(window.innerHeight, rect.bottom),
			left: Math.max(0, rect.left),
			right: Math.min(window.innerWidth, rect.right)
		  },
		  visibility_percentage: this.calculateVisibilityPercentage(feature)
		};
	  },
	  
	  // Calculate what percentage of the feature is visible
	  calculateVisibilityPercentage(feature, rect) {
		rect = rect || feature.getBoundingClientRect();
		const viewportHeight = window.innerHeight;
		const viewportWidth = window.innerWidth;
		
		const visibleHeight = Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0);
		const visibleWidth = Math.min(rect.right, viewportWidth) - Math.max(rect.left, 0);
		
		if (visibleHeight <= 0 || visibleWidth <= 0) return 0;
		
		const visibleArea = visibleHeight * visibleWidth;
		const totalArea = rect.height * rect.width;
		
		return Math.round((visibleArea / totalArea) * 100);
	  },
	  
	  // Check if element is visible in viewport (at least partially)
	  isElementVisible(element) {
		try {
		  // Micro-bailouts before expensive layout reads
		  if (!element || element.offsetParent === null) return false;
		  const cs = window.getComputedStyle(element);
		  if (cs.visibility === 'hidden' || cs.opacity === '0') return false;
		  
		  const rect = element.getBoundingClientRect();
		  const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
		  const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
		  
		  // Check if element is in viewport bounds
		  const isInViewport = (
			rect.bottom > 0 &&
			rect.right > 0 &&
			rect.top < viewportHeight &&
			rect.left < viewportWidth
		  );
		  
		  // Check if element has actual dimensions (not hidden)
		  const hasSize = rect.width > 0 && rect.height > 0;
		  
		  // Check if element is not hidden via CSS
		  const computedStyle = window.getComputedStyle(element);
		  const isNotHidden = (
			computedStyle.display !== 'none' &&
			computedStyle.visibility !== 'hidden' &&
			computedStyle.opacity !== '0'
		  );
		  
		  return isInViewport && hasSize && isNotHidden;
		} catch (error) {
		  warn('üéØ CRO Tracker: Error checking element visibility:', error);
		  return true; // Default to visible if check fails
		}
	  },
  
	  
	  // Get interaction details from event
	  getInteractionDetails(event) {
		const details = {
		  event_type: event.type,
		  target_tag: event.target.tagName,
		  target_id: event.target.id || null,
		  target_classes: event.target.className || null
		};
		
		// Add mouse/touch specific details
		if (event.clientX !== undefined) {
		  details.mouse = {
			clientX: event.clientX,
			clientY: event.clientY,
			pageX: event.pageX,
			pageY: event.pageY
		  };
		}
		
		// Add form specific details
		if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') {
		  details.form = {
			input_type: event.target.type || null,
			input_name: event.target.name || null,
			input_value: event.target.value ? event.target.value.substring(0, 100) : null // Truncate for privacy
		  };
		}
		
		return details;
	  },
	  
	  // Check if event should be throttled (performance optimization)
	  _shouldThrottleEvent(eventName, featureName) {
		const throttleKey = `${eventName}:${featureName}`;
		const now = Date.now();
		const lastEventTime = this._eventThrottle.get(throttleKey);
		
		if (lastEventTime && (now - lastEventTime) < this._throttleTimeout) {
		  return true; // Throttle this event
		}
		
		this._eventThrottle.set(throttleKey, now);
		return false; // Allow this event
	  },
  
	  // Publish event to Shopify Analytics with error handling and throttling
	  publishEvent(eventName, data) {
		try {
		  // Only throttle loaded and viewed events, not interactions
		  if (eventName !== 'feature_interacted' && this._shouldThrottleEvent(eventName, data.feature_name)) {
			return;
		  }
  
		  if (window.Shopify && Shopify.analytics && Shopify.analytics.publish) {
			// Use requestIdleCallback for better performance if available
			const publishFn = () => {
			  const eventPayload = {
				name: eventName,
				customData: data
			  };
			  Shopify.analytics.publish("custom_event", eventPayload);
			};
  
			if (window.requestIdleCallback) {
			  requestIdleCallback(publishFn, { timeout: 1000 });
			} else {
			  // Fallback to setTimeout for older browsers
			  setTimeout(publishFn, 0);
			}
		  } else {
			warn("üéØ CRO Tracker: Shopify analytics not available, event not sent:", eventName, data);
		  }
		} catch (error) {
		  this.handleError('Error publishing event', error, { eventName, data });
		}
	  },
  
	  // Comprehensive error handler - never throws, never breaks the page
	  handleError(message, error, context = null) {
		try {
		  // Create safe error info object
		  const errorInfo = {
			message: message || 'Unknown error',
			error: error ? {
			  name: error.name || 'Unknown',
			  message: error.message || 'No message',
			  stack: error.stack ? error.stack.substring(0, 500) : 'No stack trace'
			} : null,
			context: context ? {
			  elementTag: context.tagName || null,
			  elementId: context.id || null,
			  elementClass: context.className || null,
			  featureName: context.getAttribute ? context.getAttribute('data-cro-feature') || 
						  context.getAttribute('data-cro-feature-loaded') || 
						  context.getAttribute('data-cro-feature-viewed') || 
						  context.getAttribute('data-cro-feature-clicked') : null
			} : null,
			timestamp: new Date().toISOString(),
			userAgent: navigator.userAgent ? navigator.userAgent.substring(0, 200) : 'Unknown',
			url: window.location ? window.location.href : 'Unknown'
		  };
  
		  // Log to console (safe)
		  err('üö® CRO Feature Tracker Error:', errorInfo);
  
		  // Try to send error event to analytics (but don't fail if this fails)
		  try {
			if (window.Shopify && Shopify.analytics && Shopify.analytics.publish) {
			  Shopify.analytics.publish('custom_event', {
				name: 'cro_tracker_error',
				customData: {
				  error_type: 'cro_feature_tracker_error',
				  error_message: errorInfo.message,
				  error_details: errorInfo.error ? errorInfo.error.message : 'No details',
				  context: errorInfo.context,
				  timestamp: errorInfo.timestamp
				}
			  });
			}
		  } catch (analyticsError) {
			// Silently fail - we don't want error handling to cause more errors
			warn('üéØ CRO Tracker: Could not send error to analytics:', analyticsError);
		  }
  
		} catch (handlerError) {
		  // Last resort - if even error handling fails, just log to console
		  // Gate even critical errors behind debug flag for zero console output
		  err('üö® CRO Tracker: Error handler itself failed:', handlerError);
		  err('üö® Original error was:', message, error);
		}
	  }
	};
	
	// Initialize when DOM is ready with error handling
	try {
	  if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
		  try {
			FEATURE_TRACKER.init();
		  } catch (error) {
			// Gate initialization errors behind debug flag for zero console output
			err('üö® CRO Tracker: Failed to initialize on DOMContentLoaded:', error);
		  }
		}, { once: true, passive: true });
	  } else {
		FEATURE_TRACKER.init();
	  }
	  
	  // Expose globally for manual tracking
	  window.CROFeatureTracker = FEATURE_TRACKER;
	} catch (error) {
	  // Gate critical initialization errors behind debug flag for zero console output
	  err('üö® CRO Tracker: Critical initialization failure:', error);
	  // Create a safe fallback object
	  window.CROFeatureTracker = {
		init: () => warn('üéØ CRO Tracker: Fallback mode - tracker disabled due to initialization error'),
		trackFeatureLoaded: () => {},
		trackFeatureViewed: () => {},
		trackFeatureInteraction: () => {},
		handleError: (msg, error) => console.error('üö® CRO Tracker Error:', msg, error)
	  };
	}
  })();
  
  
  


      </script>